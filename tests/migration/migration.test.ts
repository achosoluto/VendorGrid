#!/usr/bin/env node

/**
 * Phase 4: Migration System Testing Suite
 * 
 * Tests the migration scripts for Keycloak authentication:
 * - validate: Validates Keycloak configuration
 * - migrate: Migrates from mock to Keycloak
 * - rollback: Rolls back to mock authentication
 * - status: Checks current authentication status
 */

import { describe, it, expect, beforeAll, afterAll, beforeEach, afterEach } from 'vitest';
import { spawn, ChildProcess } from 'child_process';
import fs from 'fs';
import path from 'path';
import axios from 'axios';

// Test configuration
const MIGRATION_SCRIPT = 'node scripts/migrate-to-keycloak.js';
const KEYCLOAK_SCRIPT = './keycloak-init/start-keycloak.sh';

// Utility class for migration testing
class MigrationTester {
  private keycloakProcess: ChildProcess | null = null;
  private httpClient = axios.create({
    timeout: 10000,
    validateStatus: () => true
  });

  async startKeycloak(): Promise<void> {
    console.log('üöÄ Starting Keycloak infrastructure for testing...');
    
    this.keycloakProcess = spawn(KEYCLOAK_SCRIPT, ['start'], {
      cwd: path.resolve(__dirname, '../..'),
      stdio: ['pipe', 'pipe', 'pipe']
    });

    // Wait for Keycloak to be ready
    await this.waitForKeycloak();
  }

  private async waitForKeycloak(): Promise<void> {
    const maxAttempts = 30;
    for (let i = 0; i < maxAttempts; i++) {
      try {
        const response = await this.httpClient.get('http://localhost:8080/realms/vendorgrid');
        if (response.status === 200) {
          console.log('‚úÖ Keycloak is ready for testing');
          return;
        }
      } catch (error) {
        // Keycloak not ready yet
      }
      await new Promise(resolve => setTimeout(resolve, 5000));
    }
    throw new Error('Keycloak failed to start within timeout');
  }

  async stopKeycloak(): Promise<void> {
    if (this.keycloakProcess) {
      this.keycloakProcess.kill('SIGTERM');
      await new Promise(resolve => {
        this.keycloakProcess?.on('exit', resolve);
        setTimeout(resolve, 5000);
      });
    }
  }

  async runMigrationCommand(command: string, cwd?: string): Promise<{ stdout: string; stderr: string; code: number }> {
    return new Promise((resolve, reject) => {
      const process = spawn('node', ['scripts/migrate-to-keycloak.js', command], {
        cwd: cwd || path.resolve(__dirname, '../..'),
        stdio: ['pipe', 'pipe', 'pipe']
      });

      let stdout = '';
      let stderr = '';

      process.stdout?.on('data', (data) => {
        stdout += data.toString();
      });

      process.stderr?.on('data', (data) => {
        stderr += data.toString();
      });

      process.on('close', (code) => {
        resolve({ stdout, stderr, code: code || 0 });
      });

      process.on('error', (error) => {
        reject(error);
      });
    });
  }

  async runKeycloakCommand(command: string): Promise<{ stdout: string; stderr: string; code: number }> {
    return new Promise((resolve, reject) => {
      const process = spawn(KEYCLOAK_SCRIPT, [command], {
        cwd: path.resolve(__dirname, '../..'),
        stdio: ['pipe', 'pipe', 'pipe']
      });

      let stdout = '';
      let stderr = '';

      process.stdout?.on('data', (data) => {
        stdout += data.toString();
      });

      process.stderr?.on('data', (data) => {
        stderr += data.toString();
      });

      process.on('close', (code) => {
        resolve({ stdout, stderr, code: code || 0 });
      });

      process.on('error', (error) => {
        reject(error);
      });
    });
  }

  getEnvPath(): string {
    return path.resolve(__dirname, '../..', '.env');
  }

  readEnv(): Record<string, string> {
    const envPath = this.getEnvPath();
    if (!fs.existsSync(envPath)) {
      return {};
    }

    const content = fs.readFileSync(envPath, 'utf8');
    const env: Record<string, string> = {};

    content.split('\n').forEach(line => {
      const trimmed = line.trim();
      if (trimmed && !trimmed.startsWith('#')) {
        const [key, ...valueParts] = trimmed.split('=');
        if (key) {
          env[key.trim()] = valueParts.join('=').trim();
        }
      }
    });

    return env;
  }

  writeEnv(env: Record<string, string>): void {
    const envPath = this.getEnvPath();
    const lines = [
      '# VendorGrid Environment Configuration',
      '# Generated by Phase 3 Keycloak Migration Script',
      ''
    ];

    Object.keys(env).forEach(key => {
      lines.push(`${key}=${env[key]}`);
    });

    fs.writeFileSync(envPath, lines.join('\n') + '\n');
  }

  getAuthProvider(): string {
    const env = this.readEnv();
    return env.AUTH_PROVIDER || 'mock';
  }

  setAuthProvider(provider: string): void {
    const env = this.readEnv();
    env.AUTH_PROVIDER = provider;
    this.writeEnv(env);
  }

  async setupTestEnvironment(): Promise<void> {
    // Configure test environment variables
    const env = this.readEnv();
    
    // Set Keycloak configuration
    env.KEYCLOAK_BASE_URL = 'http://localhost:8080';
    env.KEYCLOAK_REALM = 'vendorgrid';
    env.KEYCLOAK_CLIENT_ID = 'vendorgrid-app';
    env.KEYCLOAK_CLIENT_SECRET = 'test-secret'; // Will be updated after starting Keycloak
    env.KEYCLOAK_ADMIN_CLIENT_SECRET = 'test-admin-secret'; // Will be updated after starting Keycloak
    
    this.writeEnv(env);
  }

  async generateClientSecrets(): Promise<void> {
    // Generate client secrets using Keycloak
    const result = await this.runKeycloakCommand('secrets');
    if (result.code !== 0) {
      console.warn('‚ö†Ô∏è  Failed to generate client secrets:', result.stderr);
    }
  }

  async healthCheck(): Promise<boolean> {
    try {
      const response = await this.httpClient.get('http://localhost:3000/api/auth/status');
      return response.status === 200;
    } catch {
      return false;
    }
  }

  async reset(): Promise<void> {
    // Reset to mock authentication
    this.setAuthProvider('mock');
    await this.stopKeycloak();
  }
}

// Test Suite
describe('Migration System Testing', () => {
  let migrationTester: MigrationTester;

  beforeAll(async () => {
    migrationTester = new MigrationTester();
    await migrationTester.startKeycloak();
    await migrationTester.generateClientSecrets();
  });

  afterAll(async () => {
    await migrationTester.reset();
  });

  beforeEach(() => {
    // Reset to mock before each test
    migrationTester.setAuthProvider('mock');
  });

  describe('Status Command Tests', () => {
    it('should show current mock authentication status', async () => {
      const result = await migrationTester.runMigrationCommand('status');
      
      expect(result.code).toBe(0);
      expect(result.stdout).toContain('Current Authentication Provider: MOCK');
      expect(result.stdout).toContain('Using Mock Authentication (Development Mode)');
    });

    it('should show current Keycloak authentication status', async () => {
      // Switch to Keycloak and test
      migrationTester.setAuthProvider('keycloak');
      
      const result = await migrationTester.runMigrationCommand('status');
      
      expect(result.code).toBe(0);
      expect(result.stdout).toContain('Current Authentication Provider: KEYCLOAK');
      expect(result.stdout).toContain('Keycloak Configuration');
    });

    it('should display helpful migration instructions for mock mode', async () => {
      const result = await migrationTester.runMigrationCommand('status');
      
      expect(result.stdout).toContain('To migrate to Keycloak:');
      expect(result.stdout).toContain('1. Configure Keycloak environment variables in .env');
      expect(result.stdout).toContain('2. Run: node scripts/migrate-to-keycloak.js validate');
      expect(result.stdout).toContain('3. Run: node scripts/migrate-to-keycloak.js migrate');
    });
  });

  describe('Validation Command Tests', () => {
    it('should validate successful Keycloak configuration', async () => {
      const result = await migrationTester.runMigrationCommand('validate');
      
      expect(result.code).toBe(0);
      expect(result.stdout).toContain('‚úÖ All required Keycloak environment variables are configured');
      expect(result.stdout).toContain('‚úÖ Keycloak is accessible');
      expect(result.stdout).toContain('‚úÖ All validation checks passed!');
    });

    it('should fail validation when Keycloak is not accessible', async () => {
      // Stop Keycloak temporarily
      await migrationTester.stopKeycloak();
      
      const result = await migrationTester.runMigrationCommand('validate');
      
      expect(result.code).toBe(0); // Script doesn't exit with error code
      expect(result.stdout).toContain('‚ùå Keycloak accessibility check failed');
      expect(result.stdout).toContain('‚ùå Configuration validation failed');
      
      // Restart Keycloak
      await migrationTester.startKeycloak();
      await migrationTester.generateClientSecrets();
    });

    it('should provide helpful error messages for validation failures', async () => {
      // Remove Keycloak configuration temporarily
      const env = migrationTester.readEnv();
      delete env.KEYCLOAK_CLIENT_SECRET;
      migrationTester.writeEnv(env);
      
      const result = await migrationTester.runMigrationCommand('validate');
      
      expect(result.stdout).toContain('‚ùå Missing Keycloak environment variables:');
      expect(result.stdout).toContain('‚ùå Configuration validation failed');
    });
  });

  describe('Migration Command Tests', () => {
    it('should migrate from mock to Keycloak authentication', async () => {
      const initialProvider = migrationTester.getAuthProvider();
      expect(initialProvider).toBe('mock');
      
      const result = await migrationTester.runMigrationCommand('migrate');
      
      expect(result.code).toBe(0);
      expect(result.stdout).toContain('Migrating to Keycloak Authentication');
      expect(result.stdout).toContain('‚úÖ All validation checks passed!');
      expect(result.stdout).toContain('üéâ Migration to Keycloak completed successfully!');
      
      // Verify provider was changed
      const finalProvider = migrationTester.getAuthProvider();
      expect(finalProvider).toBe('keycloak');
    });

    it('should handle migration when already on Keycloak', async () => {
      // Set to Keycloak first
      migrationTester.setAuthProvider('keycloak');
      
      const result = await migrationTester.runMigrationCommand('migrate');
      
      expect(result.code).toBe(0);
      expect(result.stdout).toContain('‚ö†Ô∏è  Authentication is already set to Keycloak');
      expect(result.stdout).toContain('üéâ Migration to Keycloak completed successfully!');
    });

    it('should create environment backup during migration', async () => {
      const result = await migrationTester.runMigrationCommand('migrate');
      
      expect(result.stdout).toContain('üìÅ Environment backup created:');
      expect(result.stdout).toContain('üìÅ Backup created at:');
    });

    it('should provide next steps after successful migration', async () => {
      const result = await migrationTester.runMigrationCommand('migrate');
      
      expect(result.stdout).toContain('Next steps:');
      expect(result.stdout).toContain('1. Test the authentication flow: Visit /api/auth/status');
      expect(result.stdout).toContain('2. Access the application and verify login works');
      expect(result.stdout).toContain('3. Monitor the application logs for any issues');
    });

    it('should abort migration on configuration validation failure', async () => {
      // Stop Keycloak to cause validation failure
      await migrationTester.stopKeycloak();
      
      const result = await migrationTester.runMigrationCommand('migrate');
      
      expect(result.code).toBe(0); // Script doesn't exit with error code
      expect(result.stdout).toContain('‚ùå Migration aborted - configuration validation failed');
      expect(result.stdout).toContain('To complete the migration:');
      
      // Restart Keycloak
      await migrationTester.startKeycloak();
      await migrationTester.generateClientSecrets();
    });
  });

  describe('Rollback Command Tests', () => {
    it('should rollback from Keycloak to mock authentication', async () => {
      // Start with Keycloak
      migrationTester.setAuthProvider('keycloak');
      
      const result = await migrationTester.runMigrationCommand('rollback');
      
      expect(result.code).toBe(0);
      expect(result.stdout).toContain('Rolling Back to Mock Authentication');
      expect(result.stdout).toContain('‚úÖ Rolled back to mock authentication');
      expect(result.stdout).toContain('Mock authentication is now active');
      
      // Verify provider was changed
      const finalProvider = migrationTester.getAuthProvider();
      expect(finalProvider).toBe('mock');
    });

    it('should handle rollback when already on mock', async () => {
      const result = await migrationTester.runMigrationCommand('rollback');
      
      expect(result.code).toBe(0);
      expect(result.stdout).toContain('‚ö†Ô∏è  Authentication is already set to mock');
      expect(result.stdout).toContain('Rollback completed successfully!');
    });
  });

  describe('Integration Tests', () => {
    it('should complete full migration cycle (mock -> keycloak -> mock)', async () => {
      // 1. Start with mock
      expect(migrationTester.getAuthProvider()).toBe('mock');
      
      // 2. Migrate to Keycloak
      const migrateResult = await migrationTester.runMigrationCommand('migrate');
      expect(migrateResult.code).toBe(0);
      expect(migrationTester.getAuthProvider()).toBe('keycloak');
      
      // 3. Rollback to mock
      const rollbackResult = await migrationTester.runMigrationCommand('rollback');
      expect(rollbackResult.code).toBe(0);
      expect(migrationTester.getAuthProvider()).toBe('mock');
    });

    it('should validate configuration after migration cycle', async () => {
      // Migrate to Keycloak
      await migrationTester.runMigrationCommand('migrate');
      
      // Validate that Keycloak is working
      const validateResult = await migrationTester.runMigrationCommand('validate');
      expect(validateResult.code).toBe(0);
      expect(validateResult.stdout).toContain('‚úÖ All validation checks passed!');
      
      // Rollback to mock
      await migrationTester.runMigrationCommand('rollback');
      
      // Verify status shows mock
      const statusResult = await migrationTester.runMigrationCommand('status');
      expect(statusResult.stdout).toContain('Current Authentication Provider: MOCK');
    });
  });

  describe('Error Handling Tests', () => {
    it('should handle invalid commands gracefully', async () => {
      const result = await migrationTester.runMigrationCommand('invalid-command');
      
      expect(result.code).toBe(1); // Should exit with error code
      expect(result.stdout).toContain('‚ùå Unknown command: invalid-command');
      expect(result.stdout).toContain('Usage: node scripts/migrate-to-keycloak.js [command]');
    });

    it('should show help for help command', async () => {
      const result = await migrationTester.runMigrationCommand('help');
      
      expect(result.code).toBe(0);
      expect(result.stdout).toContain('Usage: node scripts/migrate-to-keycloak.js [command]');
      expect(result.stdout).toContain('Commands:');
      expect(result.stdout).toContain('status     - Check current authentication status and configuration');
      expect(result.stdout).toContain('validate   - Validate Keycloak configuration and connectivity');
      expect(result.stdout).toContain('migrate    - Migrate from mock to Keycloak authentication');
      expect(result.stdout).toContain('rollback   - Rollback from Keycloak to mock authentication');
      expect(result.stdout).toContain('Migration Flow:');
    });
  });
});

// Export for use in other test files
export { MigrationTester };